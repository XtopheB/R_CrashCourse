---
title: "Use R!"
author: " ---- \n *Christophe Bontemps*  \n  ![](www/SIAP_logo_2020_1800.png){width=30%}  "
date: 'Version: 1.55 \n (June 2025)'
output:
  learnr::tutorial: 
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to use R through online exercise and interactive coding in your browser. 
  Focus is on the computation of a few SDG indicators using tidyverse coding.
---

```{r setup, include=FALSE}
# In this chuck, all elements are loaded for the rest of the document!
library(learnr)
library(tidyverse)
library(stringr)
#library(foreign)
library(haven)

# We need to have here all objects used in multiple chunks!!
# Loading data--  

## For SDG computation (online)
  # household_survey <- read.csv2("https://raw.githubusercontent.com/XtopheB/R_CrashCourse/main/RawData/Household_Survey.csv") %>% select(-"X") %>%
  # select(c("household_id", "income", "location"), everything()) %>%
  # rename(Id = household_id)%>%
  # mutate(income = income /1000)
  
# Stored in shinyApp
household_survey <- read.csv2("./www//Household_Survey.csv") %>% 
  select(-"X") %>%
  select(c("household_id", "income", "location"), everything()) %>%
  rename(Id = household_id)%>%
  mutate(income = income /1000)

## Some objects that will be computed:
household_rural <- household_survey %>%
  filter(location == "Rural")

income_rural <- household_rural %>%
  mutate(total = sum(income))

Nb_rural <- household_rural %>%
  count()

income_rural_value <- household_rural %>%
  summarize(total = sum(income))

## -- For SDG 16.1.3

## >>>   Code to create a LIGHTER subsample  <<<<<
# envipe <- read.dbf("./RawData/TPer_Vic2.dbf")
# envipe_light <- envipe %>%
#   sample_frac(0.1, replace = FALSE)

###  Even lighter with less variables
# envipe <- read_sav("./www/TPer_Vic2_light.sav")
# 
# envipe_superlight <- envipe %>%
#    select(-matches("^AP(?!7_3_11)", perl = TRUE))  # removes all "AP" but "AP7_3_11"
# write_sav(envipe_superlight,  "./www/TPer_Vic2_superlight.sav")

# -----  Light version used  -----
# with foreign
# write.dbf(envipe_light, "./www/TPer_Vic2_light.dbf")
# envipe <- read.dbf("./www/TPer_Vic2_light.dbf")

##  Alternative with haven 
#write_sav(envipe_light,  "./www/TPer_Vic2_light.sav")

# ----

# loading the  created SPSS file
envipe <- read_sav("./www/TPer_Vic2_light.sav")

envipe2019 <- envipe %>%
  select(SEXO,EDAD, AP7_3_11,FAC_ELE)

envipe2019_clean <- envipe2019 %>%
  mutate( Age = as.numeric(as.character(EDAD)), 
          Weight = as.numeric(as.character(FAC_ELE)))

# For SDG 16.1.3
denominator <- envipe2019_clean  %>%
  summarize(weightedPop = sum(Weight))

numerator <- envipe2019_clean  %>%
  filter(AP7_3_11 == 1) %>%
  summarize(weightedPop = sum(Weight))
  
SDG  <-  (numerator/denominator) * 100


## For matrices
I3 <- matrix( c(1, 0, 0, 0, 1, 0, 0, 0, 1) , nrow =3)
A <- matrix(c(1, 2, 3, 4), nrow = 2)
B <- matrix(c(5, 6, 7, 8), nrow = 2)
InvA <- solve(A)

## vectors
v <- c(1, 2, 3)
u <- c(1, 0, 1)

# Input-Output Analysis
Z <- matrix(c(20,75,93,
              31,83,99,
              26,59,56),  nrow = 3)

M <- c(40, 110, 50)
VA <- c(42, 77, 189)
Y <- c(193,183,132,302,0)  

```

## Work with survey data and Compute SDG indicators 

Using the materials covered in the previous modules, we will start computing some simple SDGs using interactive coding and with a focus on using `tidyverse` for simple and efficient coding. 

### Learning Objectives 
At the end of this module you should be able to:   

* Run a few lines of R code
* Compute averages from Survey data
* Compute simple indicators using different methods
* Work with matrices


> *We highly recommend that you follow the order of the topics proposed in this tutorial*!

### Have you successfully completed the R-Tutorial?

```{r quiz0, echo = FALSE}
question("Have you completed the basic R- Tutorial?  (*Check all that is TRUE*):",
  answer("Yes", correct = TRUE, message = "Perfect"),
  answer("No, I'm just starting here",  message = "Please start at the beginning with the Basic R course" )
  )
  
```



## Average income from survey data

We have a data set from a survey that reports information on `r nrow(household_survey)` households, including their *location* (urban or rural), their *income* and other information. 

Let's have a look at the 5 first rows of this data set called *household_survey*:

```{r}
head(household_survey)
```

In total we have  `r ncol(household_survey)` variables to explore (*use the top right black arrow to navigate if they are not all appearing on your screen*).

> We want to compute  the average income for *rural* population.  How would you do that? 

The formula is the following: 
 
$$
Avg\_Income_{rural} = \frac{Total\_Income_{rural}}{Nb\_Households_{rural}}
$$

There are 4 basic steps: 

- **Select** only rural population 
- **Count** the number of rural households $\rightarrow$ **Denominator**
- **Compute** the total income of rural population $\rightarrow$ **Numerator**
- **ComputeÂ¨** the ratio 

We will compute this step-by step! 

### Step 1: Selecting only rural households

This can be done using the `filter` function in the *tidyverse* library. This function allows to filter only observations (rows) that satisfy a condition.

>Since we only want "rural"  households, one can filter using `location == "Rural"`. ^[Be careful of using the right spelling for "Rural" with a capital "R" letter. ]

Give it a try and create a new data frame with only rural households

```{r PopDat, exercise.eval = TRUE}
household_rural <- household_survey %>%
  filter(location == "Rural")

```

```{r PopDat1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "PopDat", exercise.cap = "Create a data set with only rural households"}
# Enter your solution below

household_rural <-
  

```

```{r PopDat1-hint-1}
# You should use the data from household_survey and the %>% operator
# Use a new line with the condition on location

household_rural <-  household_survey %>%
  
```

```{r PopDat1-hint-2}
# You can use function filter () 
# --> Write the condition in the filter() function

household_rural <- household_survey %>%
  filter()
  
```

```{r PopDat1-solution}
# Solution: Pay attention to the double == when conditioning

household_rural <- household_survey %>%
  filter(location == "Rural")

```

**Congratulations** The data frame *household_rural* has now **only** rural households. 

Check the new data frame here and observe the first rows. They should now be all rural (run code).  

```{r Popex-Valid, exercise = TRUE, exercise.eval = FALSE, exercise.setup = "PopDat"}
head(household_rural)
```

### Step 2: Counting rural households (*denominator*)

Here, we will use the data frame with **only rural** households (named *household_rural*) and count them. A useful function may be the function `count()`.

```{r PopDen1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "PopDat", exercise.cap = "Count the rural population"}
# Enter your solution below

Nb_rural <-
  

```

```{r PopDen1-hint-1}
# You should use the data from household_rural and the %>% operator
# Use a new line to compute the total of Income

Nb_rural <- household_rural %>%
  

```

```{r PopDen1-hint-2}
# You can use the function count() -->  Write the code in a new line

Nb_rural <- household_rural %>%
  count()


```


```{r PopDen1-solution}
# Solution: We simply use the count() function to compute the number of rows!
Nb_rural <- household_rural %>%
  count()

Nb_rural
```

### Step 3: Compute the total income of rural population (*numerator*) 

This is the numerator $Total\_Income_{rural}$, computed as the **sum** of household incomes **over all observations** (households in rural areas). 

To compute this value, we will start with the data frame with only rural observations  (*household_rural*), and then **sum** the incomes.
We may create a new variable (using `mutate()`) and compute the desired sum using the function `sum()` :

> Your turn!

(*Use the hints*)


```{r PopNum, exercise.eval = TRUE, exercise.setup = "PopDat"}
income_rural <- household_rural %>%
  mutate(total = sum(income))

```

```{r PopNum1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "PopNum", exercise.cap = "Compute the income sum for rural households"}
# Enter your solution below

income_rural <-
  
```

```{r PopNum1-hint-1}
# You should use the data from household_rural and the %>% operator
# Use a new line to compute the total of Income. You can use mutate()

income_rural <- household_rural %>%
  

```

```{r PopNum1-hint-2}
# We will use mutate() to create a new variable(new column)
# --> Write what we want in the () for mutate!

income_rural <- household_rural %>%
  mutate()

```

```{r PopNum1-solution}
# We use the function sum()  to compute the total
# Total has the sum of income across all rows

income_rural <- household_rural %>%
  mutate(total = sum(income))


```

#### A bit of explanation: 

- `mutate()` creates a new variable (here *total*) in a data frame
- `sum(income)` sums the income across all rows
-  So our variable `total` has that value in every row

> Check the result here:

```{r }
# Visualizing only a few variables of the result (with select())
income_rural %>%
  select(Id, income, location, total)%>%
  head()
```

We have a data frame with a variable (*total*) that has our result, but repeated for all observations!  That's the way `mutate` works. It creates a variable with the value assigned - here the sum over all observations. 

> **A solution** to reduce the data frame to a single value is to summarize the variable *total* using the function `summarize ()` instead of `mutate()`.^[The function `summarize()` returns the *mean*  of a variable. Since the variable  *total*  has only one value repeated, this gives us that value with no effort.]


```{r}
# We use the function summarize()  to resume total to a single value
income_rural_value <- household_rural %>%
  summarize(total = sum(income))

income_rural_value
  
```

> Now we can compute the ratio in the final step ! 

### Step 4: Computing the average income for rural households (*numerator/denominator*)

the result should be as simple as a simple division: 

 
$$
Avg\_Income_{rural} = \frac{Total\_Income_{rural}}{Nb\_Households_{rural}} =   \frac{Numerator}{Denominator}
$$


```{r Avg1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "PopDat", exercise.cap = "Compute the average"}
# Enter your solution below

avg_income <-
  
```

```{r Avg1-hint-1}
# The ratio is simply using the  / operator

avg_income <-  ? / ?
  

```

```{r Avg1-solution}
# Solution: Divide numerator by denominator 
# Be careful of the exact name of numerator and denominator

avg_income <- income_rural_value/Nb_rural

avg_income

```


> This required a lot of steps. Couldn't we  *pipe* ( `%>%` ) all of that? 

### Finally: A concise and efficient way of computing

In the following code, we combine all elements using the *pipe* operator `%>%` to chain operations:

> Examine the code below:


```{r final}
avg_income <- household_survey %>%
  filter(location == "Rural") %>%
  summarize(avg = sum(income) / n() )

avg_income 

```

#### A bit of explanation: 

- `filter()` keep only households from *rura*l areas.
- `sum()` computes the sum over all households (which are all rural now) 
-  `n()` is the number of observations in the current state of the data frame (*so only rural counted here*).^[`n()`is a special function that returns the number of rows in a data frame, typically used inside summarise(), mutate(), or filter() when working with *grouped data*. `count()` groups the data, counts the observations and returns a single value.]
-  The result is affected to a new variable in the data frame named here *avg*
- `summarize()` is used as a *"trick"*  to aggregate across the rows one value since the variable *avg* would be the same for each row)^[The function `summarize()` returns the *mean*  of a variable across the rows. Since here the variable created has only one value repeated, this gives us that value with no effort. There are other way to proceed, but this is one of the simplest one.]

> We will see later that there are  different methods to compute the same results. It is important though to follow the flow of operations and understand the logic of each step. ^[This is another way of computing the same value:
`avg_income2 <- household_survey %>%
  filter(location == "Rural") %>%
  pull(income) %>%
  mean()` 
  where we use `pull() `to extract the income values (only on rural households) **as a vector**  and to compute the mean of that vector using `mean()`.]


### Check your understanding

```{r quiz2, echo = FALSE}
quiz(
  question("Which function is used to subset the dataset to only rural housholds?",
    answer("mutate()", correct = FALSE,  message = " The function `mutate` is used to create a new variable"),
    answer("summarize()", correct = FALSE, message = "The function `summarize` provides a summary of a variable"),
    answer("filter()", correct = TRUE, message = "Yes, the filter() function is equivalent to subset(). It follows a logical condition and keep only obervations for wich the outcome is TRUE"), 
   allow_retry = TRUE
  ),
  
  question("Which function helps to count the number of households?",
    answer("n()", correct = TRUE),
    answer("sum()", correct = FALSE, message = "The `sum()` function just sums a variable over all observations."),
    answer("group_by()", correct = FALSE, message = " No, even if we could have counted both location using `group_by()` - but this is a bit advanced."),  
   allow_retry = TRUE
  ),
  
  question("Is this code \n
                    avg_income <- household_survey %>%
                        filter(location == 'Rural') %>%
                        summarize(avg = sum(income) / n() \n and this code:  \n
                    avg_income <- household_survey %>%
                        summarize(avg = sum(income) / n()) %>%
                        filter(location == 'Rural') \n  computing the same thing?" ,

    answer("No, because the second code computes the average income over the whole population", correct = TRUE, message = "It is important to first `filter()` the observations"),
    answer("Yes, with the pipe (`%>%`), order is not important", correct = FALSE, message = "The pipe defines a strict order on what is computed! "),
    answer("The first code does not work", correct = FALSE, message = " The first code is a correct way of writing the code"),
    answer("The second code does not work", correct = TRUE, message = " It is NOT possible to filter after summarize(), since the variable location does not exist any more"), 
   allow_retry = TRUE
    ), 
    
   question("IMPORTANT: Is there a problem in the way we compute that average?",
    answer("Yes, because we have survey and thus *weights*", correct = TRUE, message = "Yes, We must take the weights into consideration for the computation."),
    answer("No, this is the correct way to go", correct = FALSE, message = "Alas! We have to redo the computation, because we have a survey with weights for each household."),
    answer("I don't know !", correct = FALSE,  message = "Alas! We have to redo the computation, because we have a survey with weights for each household."), 
   allow_retry = TRUE
  )
)

```


### **Wait: **  Shouldn't we compute a ***weighted*** average? 

> The previous computation did not take into account the fact that,  in a survey, observations are associated with a weight characterizing their representativeness in the target population.

Let's redo the computation with the exact formula: 

 
$$
Avg\_Income\_Rural = \frac{Total\_weighted\_Income_{rural}}{Nb\_weighted\_Households_{rural}} =  \frac{\sum_i Income\_rural_{i} \times weight_i }{\sum_i weight\_rural_i}
$$
We can follow the same scheme, but note that - in step 1 - we already computed the rural sub population in a specific data frame *household_rural*, no need to recompute this! 

###  Step 2bis: Compute the **weighted** income of rural population

Using the code from step 2 above can help:  
                                   
```{r, eval= FALSE}
# This code does not use weights. Remember that the function sum() computes the sum over all observations, while summarize() is a trick to keep only one value
income_rural <- household_rural %>%
  summarize(total = sum(income))

income_rural

```

What we have to do is to is to *tweak* a bit that code to include weights, as in the correct formula above.
In the data set, the sampling weights are in the variable ***weight***

#### Your turn 

```{r WPopNum, exercise.eval = TRUE, exercise.setup = "PopDat"}
income_weighted_rural <- household_rural %>%
  summarize(total = sum(income * weight))

```


```{r WPopNum1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "WPopNum", exercise.cap = "Compute the weighted average"}
# Enter your solution below

income_rural <-
  
```

```{r WPopNum1-hint-1}
# You should use the data from household_rural and the %>% operator
# Use a new line to compute the total of Income

income_rural <- household_rural %>%
  

```

```{r WPopNum1-hint-2}
# As before, you can use function summarize() 
# But this time we need to include some weights

income_rural <- household_rural %>%
  summarize()


```

```{r WPopNum1-solution}
# Solution: We use the function sum() to compute the total
# But we multiply income by weight, while the denominator is a sum of weights

income_weighted_rural <- household_rural %>%
  summarize(weighted_average = sum(income * weight)/ sum(weight))

income_weighted_rural

```

**A bit of explanation**: 

- `income * weight` multiplies *income* with *weights*  row-by-row (for each observation).
- As previously `sum()` then sums the result across all rows
- since the variable created (weighted_average) is computed in a data frame, one must take only one value using `summarize()` as previously.

> The computation is done in 2 lines! If we start from the original data set (*household_survey*), it takes 3 lines, and the story is easy to read and tell! 

We can even `round` the result (to two digits) for better readability!

```{r}
income_weighted_rural <- household_survey %>%
  filter(location == "Rural") %>%
  summarize(weighted_average = sum(income * weight)/ sum(weight))

# For presentation, we "round" the value to include only 2 decimals
round(income_weighted_rural, 2)

```

> Let's move on and compute an SDG indicator now!

## Computing an SDG indicator

We now will learn how to compute the SDG indicator 16.1.3 - *Proportion of persons subjected to physical, psychological or sexual harassment, in the previous12 months*,  with disaggregation by sex.

We will be using the data set for the 2019 National Survey of Victimization and Perception of Public Security abbreviated **ENVIPE 2019**.^[The microdata for the survey can be accessed on the website of  [INEGI](https://www.inegi.org.mx/programas/envipe/2019/#microdatos)  under the tab labelled *Microdatos*. Related survey documentation, including the survey questionnaire, report, tabulations and data dictionary can be found under the related tabs.]
The ENVIPE 2019 data set is saved in *.sav* format (from SPSS software). To load files with that extension, we need the `haven` package (see previous module).


```{r, eval = FALSE}
library(haven)
envipe <- read_sav("TPer_Vic2.sav")

```

As usual, let us explore the *raw* data set that has **`r nrow(envipe)`** observations and **`r ncol(envipe)`** variables. We can familiarize ourselves with the names of the variables using the  function `names()`

```{r}
names(envipe)
```

> It is a good idea to extract only the variables we need for computing the indicator and work with a lighter data set.

The variables we need include (*names are in Spanish*): 

- **SEXO** :  The sex of the survey respondent
- **EDAD**: Age of respondents 
- **AP7_3_11**: Response to question 7 (option 11) "crimes on physical violence that respondents have been victims of, in the previous 12 months 
- **FAC_ELE**: Sampling weight for persons 18+ 

In the next code chunk, we create a new data frame - called *envipe2019* - with only those variables. We use for that the function `select()` to keep only the variables listed.  


```{r}
envipe2019 <- envipe %>%
  select(SEXO,EDAD, AP7_3_11,FAC_ELE)
```

> We use that data set, with still  **`r nrow(envipe2019)`** observations but only  **`r ncol(envipe2019)`** variables, in the rest of the analysis.

### Checking the *type* of each variable

When we read data into R using the import function `read.dbf()`, R tries to keep the structure of the initial data set and interprets numbers and values to assign a *type* to each variable.

> It is very important to identify which variable is of wich *type*, since some operations will only apply for some *type* of variable. For example, Computing the mean of a string variable will not work! 

Types can be **numerical** (*num*),   **integer** (*int*), a **factor** (*factor*)  a **string** (*chr*, for character) or a **Boolean** (*logi* with values TRUE/FALSE) (see the tutorial <a href="https://xtophedataviz.shinyapps.io/BasicR/#section-a-short-tutorial-on-r" target="_blank">Basic R!</a> for a review )  

> The function `str()` provides the structure of the data set and displays the *type* of each variable

```{r}
str(envipe2019)
```


***Test yourself! ***

```{r quiz3, echo = FALSE}
quiz(
  question("In the *envipe2019*, are all variables encoded as **character**? (look above,  after *@ format.spss*)",
    answer("Yes, and this is a problem!", correct = TRUE,  message = " We need to change that since some variables are numerical "),
    answer("Yes, but this is correct", correct = FALSE, message = " - Having variables that are numerical encoded as characters will cause a lot of problem, since some operations will not work correctly on factor variable"),
    answer("No, they are all numbers", correct = FALSE, message = " - All variables, including *EDAD* (Age) and *FAC_ELE* (sampling weight)  are encoded as characters."), allow_retry = TRUE
  )
  
  # question_checkbox("Which operation can be done with the variable *EDAD* (Age) encoded as a `character`? \n (*Check all correct answers*) ",
  #   answer("`summary(envipe2019$EDAD)` will provide a summary of the variable *EDAD*" ,
  #          correct = TRUE,  message = " -  `summary()` applies to factor variables. However it  will consider each unique value of EDAD as a specific factor and count the number of occurence. Not very useful here. "),
  #    answer("`mean(envipe2019$EDAD)` will provide the mean of *EDAD* " ,
  #           correct = FALSE,  message = "- It is not possible to take the mean of a factor variable"),
  #   answer("The code \n
  #   envipe2019 %>%  \n
  #       filter(EDAD ==18) \n   extracts observations where EDAD is 18", 
  #   correct = TRUE, message = "- Yes, the `filter()` function is equivalent to `subset()` and works with factors. It follows the logical condition `EDAD ==18`, keeping only obervations for which the outcome of the test is TRUE"), 
  #   answer("The code \n
  #   envipe2019 %>%  \n
  #       group_by(EDAD) %>% \n 
  #       count() \n   counts the number of observations for each unique value of EDAD",
  #   correct = TRUE, message = "- The `group_by()` function is used mostly to compute things for each category of a factor variable. This is something useful when the factor variable has few categories such as *Gender*, or married (Yes/no). Here, since EDAD is not really a factor and has many different values,  we will have a long list."), 
  #   try_again = " Please try again (check ALL correct answers) ", allow_retry = TRUE,
  #   incorrect = "- There are many good answers, try again",
  #   random_answer_order = TRUE 
  # )
)
```


> We have to convert some variables to their right type! 

We know that some variables - namely *EDAD* (Age), and *FAC_ELE* (sampling weights) - are not characters but numbers. We have to convert them to *numeric*  using  `as.numeric()`. We will then create 2 new variables (Age and Weight - beware of the upper case) using the `mutate() `function.

We take this opportunity to create a new data frame *envipe2019_clean* for clarity.


```{r}
envipe2019_clean <- envipe2019 %>%
  mutate( Age = as.numeric(EDAD), 
          Weight = as.numeric(FAC_ELE))
```


Our new data set *envipe2019_clean* has now 2 new variables (Age, and Weight)  and a total of  **`r ncol(envipe2019_clean)`** variables. We can again check their type. 


```{r}
str(envipe2019_clean)
```


> Your turn

#### Compute the summary statistics of the variables *Age* and *Weight* (be careful of the capital letters at the begining of  **A**ge and **W**eight). 


```{r envipe1,  exercise = TRUE, exercise.eval = FALSE, exercise.cap = "Compute the summary statistics"}
# Enter your solution below

envipe2019_clean %>%
  
  
```

```{r envipe1-hint-1}
# You first need to select the variables you want to use in the  summary() function

envipe2019_clean %>%
  select() %>%


```

```{r envipe1-hint-2}
# You can use function summary()  function directly

envipe2019_clean %>%
  select(Age, Weight) %>%
  summary()


```

```{r envipe1-solution}
# Solution: We use the function summary() , with some options such as the number of digits

envipe2019_clean %>%
  select(Age, Weight) %>%
  summary(digits = 3)

```

-----

#### $\hookrightarrow$  **Donât Mix Up** `summary()` and `summarize()`!

In R, `summary()` and `summarize()` are two different functions that serve different purposes:

- `summary()` is a base R function. It gives you a quick statistical overview of your data (*minimum, median, mean, and maximum* values)  for each variable in a data frame. 

- `summarize()` (or `summarise()`) is a *tidyverse* function from the `dplyr` package. Itâs used to calculate custom summary statistics (*means, counts, or proportions*), often after grouping your data with group_by(). It works with pipes (`%>%`) and is powerful for building tidy data workflows.

In short: 

- Use `summary()` to ***describe*** (variables in a data set)

- Use `summarize()` to ***compute*** (new objects in a pipe `%>%`)  

----

> Now that all the variables have the right type, we can start compute the SDG indicator 16.1.3.


### Computing the indicator 16.1.3. 

The SDG indicator  16.1.3  is defined as "*the proportion of persons subjected to physical, psychological or sexual harassment, in the previous 12 months*". This is a proportion, which means that it is a ratio, defined by the following equation: 

 
$$
Indicator  = \frac{Nb\_Victims}{Nb\_Population} \times 100
$$

In the ENVIPE questionnaire, the question **AP7_3_11.**  allows to determine if respondents have been the victims of physical, psychological harassment and sexual violence. People victim of physical violence during the reference period can be identified by  **AP7_3_11 == 1**.


But since we have survey, we now know that we should take the sampling weights into consideration. So the exact (and detailed) formula is: 

 
$$
Indicator  =  \frac{Weighted\_Nb\_Victims}{Weighted\_Nb\_Population} \times 100 =  \frac{\sum_{j= Victim} \; weight_j }{\sum_{i=All} \; weight_i} \times 100
$$

> Let's see how to compute this step by step


#### Step 1: Compute the denominator
We now know how to compute a weighted sum for both the numerator and the denominator. Let's start by the easiest: **the denominator!** 
In fact, the denominator is just a weighted count.


```{r CountPop, exercise.eval = TRUE}
denominator <- envipe2019_clean  %>%
  summarize(weightedPop = sum(Weight))
  
```


```{r CountPop1,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "CountPop", exercise.cap = "Compute the denominator"}
# Enter your solution below

denominator <-
  
```

```{r  CountPop1-hint-1}
# You should use the data set and the %>% operator
# Use a new line to compute the weighted count of the population

denominator <- envipe2019_clean %>%
  

```

```{r  CountPop1-hint-2}
# We need to compute the sum of the weights, but wich function ???? 

 denominator <- envipe2019_clean %>%
  ????(weightedPop = sum(Weight))
  

```

```{r  CountPop1-solution}
# Solution: We use the function summarize() to have only one value

denominator <- envipe2019_clean  %>%
  summarize(weightedPop = sum(Weight))

denominator

```

#### Step 2: Compute the numerator

Here again, we need to compute a weighted sum, but only for victims, that is only when the variable `AP7_3_11`  is coded as ` 1 `. 

> Hint: You can use the solution of the previous code and modify it for computing the numerator! 


```{r CountPop2,  exercise = TRUE, exercise.eval = FALSE, exercise.setup = "CountPop", exercise.cap = "Compute the numerator"}
# Enter your solution below

numerator <-
  
```

```{r  CountPop2-hint-1}
# We can start with the previous code and use filter() somewhere. Insert it in the code below:

numerator <- envipe2019_clean  %>%
  summarize(weightedPop = sum(Weight))
  

```

```{r  CountPop2-solution}
# Using filter(), we compute the same sum of weights but only for victims!  
# Note the use of  ==  for filtering

numerator <- envipe2019_clean  %>%
  filter(AP7_3_11 == 1) %>%
  summarize(weightedPop = sum(Weight))
  
numerator
```


#### Step 3: Compute the ratio

```{r RatioVictim}
# The SDG 16.1.3 is just the ratio; Since we want the percentage, we multiply by 100
SDG  <-  (numerator/denominator) * 100

# Display result
SDG

```


So the value of the SDG 16.1.3 in our sample is **`r round(pull(SDG), 2)`**. But its computation required 3 steps, and several auxiliary objects (*numerator, denominator*). 

> We can do this in a single piece of code, using the pipe `%>%` to link all operations!

Examine the code below. 


```{r}
SDG_16.1.3 <- envipe2019_clean  %>%
  mutate(WeightedPop_All = sum(Weight)) %>%
  filter(AP7_3_11 ==1) %>%
  summarize( Indicator = sum(Weight / WeightedPop_All) *100) 

SDG_16.1.3
```


And the result is exactly the same! 

#### A bit of explanation:

We follow the slightly simpler formula: 
 
$$
SDG\_16.1.3  =  \frac{\sum_{j= Victim} \; weight_j }{\sum_{i=All} \; weight_i} \times 100 =  \sum_{j= Victim}\frac{ weight_j }{\sum_{i=All} \; weight_i} \times 100  \\ 
Or:  SDG\_16.1.3  =  \sum_{j= Victim} \frac{weight_j }{WeightedPop_{All}} \times 100 
$$

- `mutate(TotalPop = sum(Weight))` calculates the row-sum of the weighted population **for the full data set**. The result is stored in the variable *WeightedPop*. This value is repeated for all raw in the data frame and this is our denominator. 

- After filtering (*i.e.*, selecting only the victims: `AP7_3_11 == 1`), we compute the percentage by adding over all rows (with `sum() `) the ratio of the weight of each victim, divided by the sum of the weights for the entire population stored in `WeightedPop`. We then embed this in `summarize()` to get only one number.

### Another way of doing it (If you want)

```{r}
SDG_16.1.3 <- envipe2019_clean  %>%
  mutate(WeightedPop_All = sum(Weight)) %>%
  filter(AP7_3_11 ==1) %>%
  summarize( Indicator = 100* sum(Weight) / unique(WeightedPop_All)) 
  
SDG_16.1.3
  
```

- First 3 lines are the same as previous computation 

- After filtering (*i.e.*, selecting only the victims: `AP7_3_11 == 1`), we compute the percentage in `summarize()`. The sum of weights,  `sum(Weight)`, is done here only on the sub population of victims ( *i.e.*, our *numerator*) divided by the complete weighted population  generated by `unique(WeightedPop_All)` (our *denominator*). We have to use   `unique()`  because *WeightedPop_All* is repeated across all rows, and we only want a single value for the denominator.^[We could have used `max(WeightedPop_All)` or `min(WeightedPop_All)` or even `mean(WeightedPop_All)`, they all provide the same value as `unique(WeightedPop_All)`.]


These examples show that there are always multiple ways of computing a result, and all lead to same result( fortunately!). However, ***concision*** and ***clarity*** are two important attributes of any code.  We encourage you to always rethink your code to see if there is a "better" way to compute the same thing. It is also a nice exercise to try different methods and compare if the results are the same.  

> But there is more: This way of computing is extremely powerful and versatile!

### Disagregating the SDG indicator 16.1.3 by Sex

The ***magic*** with the code we used for computing the indicator 16.1.3 is that it is extremely easy and straightforward to compute that indicator **for each value** of the factor variable *SEXO* using the powerful function `group_by()`. 


The function `group_by()`  is used to compute in the same way (that is it executes the same code) for each subgroup of the factor variable SEXO - where Male is coded as SEXO = 1 and Female as SEXO = 2.

No need to repeat code for each value! 


```{r}

SDG_16.1.3_Sex <- envipe2019_clean  %>%
  group_by(SEXO) %>%
  mutate(WeightedPop_All = sum(Weight)) %>%
  filter(AP7_3_11 ==1) %>%
  summarize( Indicator = sum(Weight /WeightedPop_All) *100) 
  

SDG_16.1.3_Sex
  
```


There is much more to learn with `tidyverse` and you will improve your skills only with practice. 

To learn, more please read the [Tidyverse reference manual](https://dplyr.tidyverse.org/reference/index.html) and  enjoy other tutorials like [this one](https://www.r-bloggers.com/2021/04/tidyverse-in-r-complete-tutorial/)  or [that one](https://www.pkimes.com/PR2019replicathon/tutorials/0b_R_tidyverse.html) and search on the web by yourself, there are hundreds of examples.

> Let's move to something different now.


## Matrices and vectors

We now introduce the basics of vectors and matrices in R. These are essential for understanding Input-Output analysis later.

### Matrices

Matrices are 2D arrays of numbers, we use the function `matrix()` to define one. To create a 2x2 matrix, we simply provide 4 numbers composing the matrix in their reading order and specify the dimension of the matrix, here using `nrow = 2`.  


```{r}
M <- matrix(c(1, 2, 3, 4), nrow = 2)
M
```


> Your turn! 

#### Create a $3 \times 3$ identity matrix 

The result should be the matrix $I_3$:  
$$
I_3 = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

```{r Idmatrix,  exercise = TRUE, exercise.eval = FALSE, exercise.cap = "Compute the 3-D Identity matrix "}
# Enter your solution below

I3 <- 
  
```


```{r Idmatrix-hint-1}
# You need to use the matrix() function 

I3 <- matrix()

```


```{r Idmatrix-hint-2}
# Since this is a 3x3 matrix, we can specify the number of rows

I3 <- matrix(      , nrow =3)


```

```{r Idmatrix-solution}
# Solution: : The sequence of numbers (0 and 1) should be carefully written  

I3 <- matrix( c(1, 0, 0, 0, 1, 0, 0, 0, 1) , nrow =3)
I3

```

As we can imagine, there is also a function, `diag()`, for creating diagonal matrices, including  the identity matrix. We can use then simplify our life by using ` I3 <- diag(3)`. The `diag()` function can also be used to extract or replace the diagonal of a matrix. 

### Matrix operations

***Addition and substraction***

Let's work here with:  
$$ A = \begin{bmatrix}
1 & 3  \\
2 & 4  
\end{bmatrix}  \;  and \;  B = 
\begin{bmatrix}
2 & 0  \\
0 & 1 
\end{bmatrix}
$$


One can add matrices of the same dimensions, simply by using ` + `. **Subtraction** works similarly with ` - `.


```{r}
# Adding two matrices A and B 
A <- matrix(c(1, 2, 3, 4), nrow = 2)
B <- matrix(c(2, 0, 0, 1), nrow = 2)

A + B

```


```{r}
# Subtraction with two matrices A and B 
A-B
```

***Multiplication***

Two matrices can be multiplied if the number of columns in the lead (or first) matrix matches the number of rows in the lag (or second) matrix. Use` %*% ` for matrix multiplication to distinguish from *term-by-term multiplication* performed by ` * `


```{r}
# Matrix multiplication
C = A %*% B  
C

```

With the previous matrices $A$ and $B$, the result is $C = AB$:  $$
C = \begin{bmatrix}
1 & 3  \\
2 & 4  
\end{bmatrix} \times
\begin{bmatrix}
2 & 0  \\
0 & 1 
\end{bmatrix} = \begin{bmatrix}
2 & 3  \\
4 & 4 
\end{bmatrix} $$


***Matrix Inversion***

When a matrix is invertible, it can be useful to invert it. This will be useful for input-output analysis.  

```{r}
# Invert the matrix A
InvA <- solve(A)
# Display the inverse of A
InvA

```

> Your turn! 

#### Verify that $A \times InvA  = I_2$!
The product of a matrix $A$ by its inverse $InvA$ should be the identity matrix $I_2$. Compute that inverse of matrix $A$ and verify! 


```{r Invert,  exercise = TRUE, exercise.eval = FALSE, exercise.cap = "Verify the inverted matrix"}
# Enter your solution below


  
```


```{r Invert-hint-1}
# Use the function  solve() to create the inverse of A

InvA <- solve(A)

```


```{r Invert-solution}
# Solution: The product of A and InvA should be the identity (dimension 2)!
InvA <- solve(A)
A %*% InvA

```

Of course, the matrix A has to be invertible. If not,   `solve(A)` will return an error. 

***Division*** is not a standard matrix operation. This is often approached by multiplying the lead matrix $A$ with an inverse of the lag matrix $B^{-1}$. The column dimension of the lead matrix should be the same as the row dimension of the lag matrix.  

For example, we can compute $D = AB^{-1}$ as:

$$
D = \begin{bmatrix}
1 & 3  \\
2 & 4  
\end{bmatrix} \times
\begin{bmatrix}
0.5 & 0  \\
0 & 1 
\end{bmatrix} = \begin{bmatrix}
0.5 & 3  \\
1 & 4 
\end{bmatrix}
$$



```{r}
# Matrix Division
InvB <- solve(B)
D = A %*% InvB  
D

```
***Transpose*** 

A matrix can be transposed by interchanging its rows and columns. The first row becomes the first column and vice versa. The transpose of A is denoted by $A'$ or $A^t$ 

 
```{r}
# Transpose of a Matrix 
E = t(A) 

E  
```


***Test yourself! ***

```{r quizMat, echo = FALSE}
quiz(
question("What is the result of `A %*% B`?",
answer("A matrix multiplication of A and B", correct = TRUE),
answer("An element-wise multiplication of A and B", correct = FALSE),
answer("The transpose of matrix A", correct = FALSE),
correct = "Yes! `%*%` performs matrix multiplication in R.",
incorrect = "Remember, `%*%` is used for matrices.",
allow_retry = TRUE
),

question("What does `t(A)` do?",
answer("Returns the transpose of matrix A", correct = TRUE),
answer("Returns the inverse of matrix A", correct = FALSE),
answer("Returns the determinant of matrix A", correct = FALSE),
correct = "Exactly! `t()` transposes a matrix.",
incorrect = "There other matrix manipulations", 
allow_retry = TRUE
),

question("What value is returned by A[2,1]? (Use the matrix A above)",
answer("2", correct = TRUE),
answer("3", correct = FALSE),
answer("4", correct = FALSE),
correct = "Right! `A[2,1]` accesses the 2nd row, 1st column of matrix A.",
incorrect = "Check your row and column indices carefully.", 
allow_retry = TRUE
)
)
```

<!--

## An Input-Output Analysis

In this exercise we will do the **first steps**  of an *Input-Output* analysis  using a $3 \times 3$ industry-by-industry table (named $Ind_1$, $Ind_2$, $Ind_3$). Steps include:

- Computing the technical coefficients
- Computing the Leontief inverse, 
- Computing the value-added and import multipliers, and
- Computing the emissions intensity.

The core of the analysis is the transaction matrix $Z$ , which shows how much each industry buys from and sells to the others. Each row signifies the output of an industry, particularly, how the production of one industry is used as intermediates by other industries (Z) or as final demand (Y). The column denotes the inputs, *i.e*., intermediate and primary inputs, that an industry needs to produce its output. One of the fundamental identities of an input-output table is that the total input of each industry should equal the total output of the same industry. This means the column sum of industry $i$ is equal to the row sum of the same industry $i$. 


```{r}
# Transaction matrix: Inputs (columns) to Outputs (rows)
Z <- matrix(c(20,75,93,
              31,83,99,
              26,59,56),  nrow = 3)

# We can add names to rows and columns here
colnames(Z) <- c("I-IND1", "I-IND2", "I-IND3")
rownames(Z) <- c("0-IND1", "0-IND2", "0-IND3")

# Display the matrix
Z
```

The matrix $Z$, is the **transaction matrix** and will play an important role in analyzing inter-industry linkages. $$
Z = \begin{bmatrix}
20 & 75 & 93 \\ 
31 & 83 & 99 \\  
26 & 59 & 56
\end{bmatrix}$$


We can also define the vector of the values of **imported inputs** $M$, as well as the **Value added** $VA$, and the **final demand** for each good $Y$. 


```{r}
# Imported inputs 
M <- c(40, 110, 50)

# Value added 
VA <- c(42, 77, 189)

# Final demand
Y <- c(193,183,132,302,0)  
```


### Step 1: Compute Total Output (X)

The total output $X$ of each industry is the sum of intermediate consumption, imported inputs, and value-added. Similarly, it is equal to the sum of intermediate consumption and final demand. The intermediate consumption of an industry is calculated as the sum of all elements in the columns of that industry in the transaction matrix $Z$. For that, we can use the function `colSums()` that computes the sum of the values in each column of a matrix. The result is a line vector. 

```{r}
# creating a vector with the sum of the values in each column
colSums(Z)
```

The total output ($TO$) for each industry, is then the sum of the vectors representing the intermediate consumption (from Z), imported inputs (M) and value-added (VA).

```{r}
# The total output is a sum of  vectors
TO<- colSums(Z) + M + VA 
TO
```

### Step 2: Construct the Input-Output Matrix 

It is very often useful to combine matrices with same number of rows, or same number of columns. We use for that the functions `rbind()` and `cbind()` respectively. 

```{r}
Mat <- rbind(Z,M,VA) 
Mat <- cbind(Mat,Y)
```


```{r}
# GO <- colSums(Mat) 
# 
# Mat <- rbind(Mat,GO) 
# 
# GO2 <- rowSums(Mat) 
# 
# Mat <- cbind(Mat,GO2) 
```

 
### Check that total input = total output 

GO[1:3]==GO2[1:3] 

 

#Check that GDP by production approach = GDP by expenditure approach 

GDP_P <- Reduce("+",VA) 

GDP_P 

GDP_E <- Reduce("+",Y) - Mat[4,5] 

GDP_E 

GDP_P == GDP_E 



### Step 2: Technical Coefficient Matrix


The **technical coefficient matrix** $A$,  shows the input required from each industry per unit of output of each industry. 

$$ A_{ij} = \frac{Z_{ij}}{TO_j}$$

This requires a computation by dividing each column of $Z$ by the total output ($TO$). 


***Chesca***: I need help here! This is difficult to explain , and the computation uses transposes and term-by-term computation....  I think this is tricky.... 

```{r}
# some explanations needed here !!!
MatA <- t(t(Z) / TO)
MatA
```


### Step 3: Leontief Inverse

We compute the **Leontief Inverse** \(B = (I - A)^{-1}\):

```{r}

I3 <- diag(3)

B <- solve(I3 - MatA)
B

```

-->

## Conclusion

> This training is just a start!

You've taken significant steps toward mastering R as a tool for manipulating, analyzing, and computing some  official statistics. 

Youâve learned how to produce a few lines of R code, import data and compute averages from survey data, how to compute simple indicators using different methods using a consistent and readable grammar of data science. You also have explored the simplicity and power of computation using **tidyverse** and even done a bit of of **matrix manipulation** that are often essential in statistics and SDG monitoring.

These tools are not just programming tricks, they are foundations for **modern, agile, and reproducible statistical systems**. 

###  Where to go from here?

* **Practice** on real datasets from your institution. Start simple and with a clear goal.
* **Collaborate** by sharing scripts, or with coding sessions of *pair programming*^[In **pair programming** two persons work together on just one computer, meaning they work simultaneously (one typing , one reading) on a code. this is a very efficeint way of learning ([more here](https://en.wikipedia.org/wiki/Pair_programming)).]
* **Explore** the web to find examples and code similar to what you want to do. Then reuse and tweak the code to your needs. 
* **Continue learning** through platforms like [R for Data Science](https://r4ds.had.co.nz/), [Posit recipes](https://posit.cloud/learn/recipes), and  [A ModernDive into R and the Tidyverse](https://moderndive.com/) among many useful references. You can also use *ChatGPT* to help you with some simple requests and code debugging. Be careful though of mistakes,  fake packages and confidential information. 

### Another **R** is possible

In this course, we focused on the **tidyverse** approach to R,  not because base R isnât powerful, but because **tidyverse** offers a clearer, more consistent, and beginner-friendly grammar for working with data. This modern toolkit helps you think in terms of data pipelines, making your code easier to read, share, and scale across projects. 

With time, you'll learn how to code with R core functions and language. Don't be afraid, what you have learned here with the **tidyverse** will still help you!   

> Good luck! 

---

### References:
Richard, Cotton (2013). Learning R. Sebastopol, California: OâReilly Media.

RStudio IDE. (2021). RStudio. Retrieved October 4, 2021, from [https://www.rstudio.com/products/rstudio/download/](https://www.rstudio.com/products/rstudio/download/)

*Posit Primers* developed by RStudio (now *Posit*) are also useful references [https://posit.cloud/learn/primers](https://posit.cloud/learn/primers)

---
<p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><span property="dct:title">This tutorial, created</span> by <span property="cc:attributionName">Christophe Bontemps (SIAP)</span>, is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>